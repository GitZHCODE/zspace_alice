// First, add a Quaternion class to your Math.h/Math.cpp

class Quaternion {
public:
    float x, y, z, w;

    Quaternion() : x(0), y(0), z(0), w(1) {}
    Quaternion(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {}
    
    // Create from axis-angle
    static Quaternion fromAxisAngle(const Vec3& axis, float angle) {
        float halfAngle = angle * 0.5f;
        float s = std::sin(halfAngle);
        Vec3 normalizedAxis = axis.normalized();
        return Quaternion(
            normalizedAxis.x * s,
            normalizedAxis.y * s,
            normalizedAxis.z * s,
            std::cos(halfAngle)
        );
    }
    
    // Create from Euler angles (Z-up convention: Z-Y-X order)
    static Quaternion fromEuler(float pitch, float yaw, float roll) {
        float cx = std::cos(pitch * 0.5f);
        float sx = std::sin(pitch * 0.5f);
        float cy = std::cos(yaw * 0.5f);
        float sy = std::sin(yaw * 0.5f);
        float cz = std::cos(roll * 0.5f);
        float sz = std::sin(roll * 0.5f);
        
        return Quaternion(
            sx * cy * cz - cx * sy * sz,  // x
            cx * sy * cz + sx * cy * sz,  // y
            cx * cy * sz - sx * sy * cz,  // z
            cx * cy * cz + sx * sy * sz   // w
        );
    }
    
    // Create lookAt quaternion (Z-up)
    static Quaternion lookAt(const Vec3& forward, const Vec3& up = Vec3(0, 0, 1)) {
        Vec3 f = forward.normalized();
        Vec3 r = f.cross(up).normalized();
        Vec3 u = r.cross(f).normalized();
        
        // Build rotation matrix
        Mat4 rotMatrix;
        rotMatrix.m[0] = r.x;  rotMatrix.m[4] = f.x;  rotMatrix.m[8] = u.x;   rotMatrix.m[12] = 0;
        rotMatrix.m[1] = r.y;  rotMatrix.m[5] = f.y;  rotMatrix.m[9] = u.y;   rotMatrix.m[13] = 0;
        rotMatrix.m[2] = r.z;  rotMatrix.m[6] = f.z;  rotMatrix.m[10] = u.z;  rotMatrix.m[14] = 0;
        rotMatrix.m[3] = 0;    rotMatrix.m[7] = 0;    rotMatrix.m[11] = 0;    rotMatrix.m[15] = 1;
        
        return fromMatrix(rotMatrix);
    }
    
    // Convert rotation matrix to quaternion
    static Quaternion fromMatrix(const Mat4& m) {
        float trace = m.m[0] + m.m[5] + m.m[10];
        
        if (trace > 0) {
            float s = std::sqrt(trace + 1.0f) * 2.0f;
            return Quaternion(
                (m.m[9] - m.m[6]) / s,
                (m.m[2] - m.m[8]) / s,
                (m.m[4] - m.m[1]) / s,
                0.25f * s
            );
        } else if (m.m[0] > m.m[5] && m.m[0] > m.m[10]) {
            float s = std::sqrt(1.0f + m.m[0] - m.m[5] - m.m[10]) * 2.0f;
            return Quaternion(
                0.25f * s,
                (m.m[1] + m.m[4]) / s,
                (m.m[2] + m.m[8]) / s,
                (m.m[9] - m.m[6]) / s
            );
        } else if (m.m[5] > m.m[10]) {
            float s = std::sqrt(1.0f + m.m[5] - m.m[0] - m.m[10]) * 2.0f;
            return Quaternion(
                (m.m[1] + m.m[4]) / s,
                0.25f * s,
                (m.m[6] + m.m[9]) / s,
                (m.m[2] - m.m[8]) / s
            );
        } else {
            float s = std::sqrt(1.0f + m.m[10] - m.m[0] - m.m[5]) * 2.0f;
            return Quaternion(
                (m.m[2] + m.m[8]) / s,
                (m.m[6] + m.m[9]) / s,
                0.25f * s,
                (m.m[4] - m.m[1]) / s
            );
        }
    }
    
    // Convert to rotation matrix
    Mat4 toMatrix() const {
        float xx = x * x;
        float yy = y * y;
        float zz = z * z;
        float xy = x * y;
        float xz = x * z;
        float yz = y * z;
        float wx = w * x;
        float wy = w * y;
        float wz = w * z;
        
        Mat4 result;
        result.m[0] = 1 - 2 * (yy + zz);  result.m[4] = 2 * (xy - wz);      result.m[8] = 2 * (xz + wy);       result.m[12] = 0;
        result.m[1] = 2 * (xy + wz);      result.m[5] = 1 - 2 * (xx + zz);  result.m[9] = 2 * (yz - wx);       result.m[13] = 0;
        result.m[2] = 2 * (xz - wy);      result.m[6] = 2 * (yz + wx);      result.m[10] = 1 - 2 * (xx + yy);  result.m[14] = 0;
        result.m[3] = 0;                  result.m[7] = 0;                  result.m[11] = 0;                  result.m[15] = 1;
        
        return result;
    }
    
    // Basic operations
    Quaternion operator*(const Quaternion& q) const {
        return Quaternion(
            w * q.x + x * q.w + y * q.z - z * q.y,
            w * q.y + y * q.w + z * q.x - x * q.z,
            w * q.z + z * q.w + x * q.y - y * q.x,
            w * q.w - x * q.x - y * q.y - z * q.z
        );
    }
    
    Quaternion normalized() const {
        float length = std::sqrt(x*x + y*y + z*z + w*w);
        if (length < 1e-6f) return Quaternion(0, 0, 0, 1);
        return Quaternion(x/length, y/length, z/length, w/length);
    }
    
    Quaternion conjugate() const {
        return Quaternion(-x, -y, -z, w);
    }
    
    // Rotate a vector
    Vec3 rotate(const Vec3& v) const {
        Quaternion q_v(v.x, v.y, v.z, 0);
        Quaternion result = (*this) * q_v * conjugate();
        return Vec3(result.x, result.y, result.z);
    }
    
    // Spherical linear interpolation
    static Quaternion slerp(const Quaternion& a, const Quaternion& b, float t) {
        Quaternion qa = a.normalized();
        Quaternion qb = b.normalized();
        
        float dot = qa.x * qb.x + qa.y * qb.y + qa.z * qb.z + qa.w * qb.w;
        
        // If the dot product is negative, slerp won't take the shorter path.
        if (dot < 0.0f) {
            qb = Quaternion(-qb.x, -qb.y, -qb.z, -qb.w);
            dot = -dot;
        }
        
        if (dot > 0.9995f) {
            // Linear interpolation for very close quaternions
            return Quaternion(
                qa.x + t * (qb.x - qa.x),
                qa.y + t * (qb.y - qa.y),
                qa.z + t * (qb.z - qa.z),
                qa.w + t * (qb.w - qa.w)
            ).normalized();
        }
        
        float theta = std::acos(dot);
        float sinTheta = std::sin(theta);
        float wa = std::sin((1.0f - t) * theta) / sinTheta;
        float wb = std::sin(t * theta) / sinTheta;
        
        return Quaternion(
            wa * qa.x + wb * qb.x,
            wa * qa.y + wb * qb.y,
            wa * qa.z + wb * qb.z,
            wa * qa.w + wb * qb.w
        );
    }
};

// Modified Transform class to use quaternions
class Transform {
public:
    Transform() 
        : m_position(0, 0, 0)
        , m_rotation(0, 0, 0, 1)  // Identity quaternion
        , m_scale(1, 1, 1)
        , m_dirty(true)
        , m_worldDirty(true)
        , m_parent(nullptr)
    {
    }

    // Position
    void setPosition(const Vec3& position) { m_position = position; markDirty(); }
    const Vec3& getPosition() const { return m_position; }

    // Rotation (now using quaternions)
    void setRotation(const Quaternion& rotation) { m_rotation = rotation.normalized(); markDirty(); }
    const Quaternion& getRotation() const { return m_rotation; }
    
    void setRotationEuler(const Vec3& euler) { 
        m_rotation = Quaternion::fromEuler(euler.x * DEG_TO_RAD, euler.y * DEG_TO_RAD, euler.z * DEG_TO_RAD); 
        markDirty(); 
    }
    
    Vec3 getRotationEuler() const {
        // Convert quaternion back to Euler angles if needed
        // This is complex and can have gimbal lock issues
        // Better to work with quaternions directly
        return Vec3(0, 0, 0); // Placeholder
    }

    // Scale
    void setScale(const Vec3& scale) { m_scale = scale; markDirty(); }
    const Vec3& getScale() const { return m_scale; }

    // Transform operations
    void translate(const Vec3& translation) { m_position += translation; markDirty(); }
    void rotate(const Quaternion& rotation) { m_rotation = rotation * m_rotation; markDirty(); }
    void rotateAxis(const Vec3& axis, float angle) { 
        rotate(Quaternion::fromAxisAngle(axis, angle)); 
    }

    // Direction vectors (Z-up convention)
    Vec3 forward() const { return m_rotation.rotate(Vec3(0, 1, 0)); }  // +Y forward
    Vec3 right() const { return m_rotation.rotate(Vec3(1, 0, 0)); }    // +X right  
    Vec3 up() const { return m_rotation.rotate(Vec3(0, 0, 1)); }       // +Z up

    // LookAt using quaternions
    void lookAt(const Vec3& target, const Vec3& up = Vec3(0, 0, 1)) {
        Vec3 forward = (target - m_position).normalized();
        m_rotation = Quaternion::lookAt(forward, up);
        markDirty();
    }

    // Matrix operations
    const Mat4& getMatrix() const {
        if (m_dirty) {
            updateMatrix();
        }
        return m_localMatrix;
    }

    // Transform points and directions
    Vec3 transformPoint(const Vec3& point) const {
        return m_rotation.rotate(Vec3(point.x * m_scale.x, point.y * m_scale.y, point.z * m_scale.z)) + m_position;
    }
    
    Vec3 transformDirection(const Vec3& direction) const {
        return m_rotation.rotate(Vec3(direction.x * m_scale.x, direction.y * m_scale.y, direction.z * m_scale.z));
    }

private:
    Vec3 m_position;
    Quaternion m_rotation;  // Now using quaternion instead of Euler angles
    Vec3 m_scale;

    mutable Mat4 m_localMatrix;
    mutable Mat4 m_worldMatrix;
    mutable bool m_dirty;
    mutable bool m_worldDirty;

    Transform* m_parent;
    std::vector<Transform*> m_children;

    void updateMatrix() const {
        Mat4 translation = Mat4::translation(m_position);
        Mat4 rotation = m_rotation.toMatrix();
        Mat4 scale = Mat4::scale(m_scale);

        m_localMatrix = translation * rotation * scale;
        m_dirty = false;
    }
    
    void markDirty() {
        m_dirty = true;
        markWorldDirty();
    }
    
    void markWorldDirty() {
        m_worldDirty = true;
        for (Transform* child : m_children) {
            child->markWorldDirty();
        }
    }
};

// Camera class modifications for quaternion-based orbit controls
class Camera {
public:
    Camera() 
        : m_orbitCenter(0, 0, 0)
        , m_orbitDistance(15.0f)
        , m_orbitRotation(0, 0, 0, 1)  // Identity quaternion
    {
        updateOrbitPosition();
        updateProjection();
    }

    // Orbit controls using quaternions
    void orbit(const Vec3& center, float deltaX, float deltaY, float distance) {
        m_orbitCenter = center;
        m_orbitDistance = distance;

        // Create rotation quaternions for mouse movement
        Quaternion yawRotation = Quaternion::fromAxisAngle(Vec3(0, 0, 1), -deltaX * DEG_TO_RAD);
        Quaternion pitchRotation = Quaternion::fromAxisAngle(Vec3(1, 0, 0), deltaY * DEG_TO_RAD);
        
        // Apply rotations to current orbit rotation
        m_orbitRotation = yawRotation * m_orbitRotation * pitchRotation;
        m_orbitRotation = m_orbitRotation.normalized();

        updateOrbitPosition();
    }

    void updateOrbitPosition() {
        // Calculate offset from center using quaternion
        Vec3 offset = m_orbitRotation.rotate(Vec3(0, -m_orbitDistance, 0));  // Start looking along -Y
        
        Vec3 position = m_orbitCenter + offset;
        m_transform.setPosition(position);
        m_transform.lookAt(m_orbitCenter, Vec3(0, 0, 1));
        
        m_viewDirty = true;
    }

    // Smooth camera interpolation
    void smoothOrbitTo(const Vec3& center, const Quaternion& targetRotation, float distance, float t) {
        m_orbitCenter = Vec3::lerp(m_orbitCenter, center, t);
        m_orbitDistance = lerp(m_orbitDistance, distance, t);
        m_orbitRotation = Quaternion::slerp(m_orbitRotation, targetRotation, t);
        
        updateOrbitPosition();
    }

private:
    Vec3 m_orbitCenter;
    float m_orbitDistance;
    Quaternion m_orbitRotation;  // Quaternion for orbit rotation
    
    // Helper function
    float lerp(float a, float b, float t) {
        return a + t * (b - a);
    }
};